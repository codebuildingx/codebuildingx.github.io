import{ab as n,G as a,H as e,ad as s}from"./framework-f86f98ae.js";const t={},p=s(`<h2 id="c-基础" tabindex="-1"><a class="header-anchor" href="#c-基础" aria-hidden="true">#</a> c++基础</h2><h3 id="c-内存模型" tabindex="-1"><a class="header-anchor" href="#c-内存模型" aria-hidden="true">#</a> c++内存模型</h3><p>C++内存分为5个区域（堆栈全常代)</p><p><strong>堆 heap</strong> ： 由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”</p><p><strong>栈 stack</strong> ： 是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。 存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。</p><p><strong>全局/静态存储区 （.bss段和.data段）</strong> ： 全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。</p><p><strong>常量存储区 （.rodata段）</strong> ： 存放常量，不允许修改（通过非正当手段也可以修改）</p><p><strong>代码区 （.text段）</strong> ： 存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）</p><h3 id="区别以下指针类别" tabindex="-1"><a class="header-anchor" href="#区别以下指针类别" aria-hidden="true">#</a> 区别以下指针类别</h3><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</p><p>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</p><p>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</p><p>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</p><h3 id="new、operator-new与placement-new区别是什么" tabindex="-1"><a class="header-anchor" href="#new、operator-new与placement-new区别是什么" aria-hidden="true">#</a> new、operator new与placement new区别是什么?</h3><p><strong>new</strong>：</p><p>new是一个关键字，不能被重载。</p><p>new 操作符的执行过程如下：</p><ol><li>调用operator new分配内存 ；</li><li>调用构造函数生成类对象；</li><li>返回相应指针。</li></ol><p><strong>operator new</strong>：</p><p>operator new就像operator + 一样，是<strong>可以重载</strong>的。如果类中没有重载operator new，那么调用的就是<strong>全局的::operator new</strong>来完成堆的分配。同理，operator new[]、operator delete、operator delete[]也是可以重载的。</p><p><strong>placement new</strong>：</p><p><strong>只是operator new重载的一个版本</strong>。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。</p><p>如果你想在<strong>已经分配的内存</strong>中创建一个对象，使用new时行不通的。也就是说placement new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中void* p实际上就是指向一个已经分配好的内存缓冲区的的首地址。</p><p>STL中常用placement new去指定内存地址创建对象。</p>`,25),o=[p];function r(c,i){return a(),e("div",null,o)}const d=n(t,[["render",r],["__file","Outline.html.vue"]]);export{d as default};
